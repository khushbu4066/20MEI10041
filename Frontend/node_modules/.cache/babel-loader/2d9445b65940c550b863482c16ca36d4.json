{"ast":null,"code":"import { isAccessorNode, isArrayNode, isConstantNode, isFunctionNode, isIndexNode, isObjectNode, isOperatorNode } from '../../utils/is.js';\nimport { createUtil } from './simplify/util.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'simplifyCore';\nvar dependencies = ['equal', 'isZero', 'add', 'subtract', 'multiply', 'divide', 'pow', 'AccessorNode', 'ArrayNode', 'ConstantNode', 'FunctionNode', 'IndexNode', 'ObjectNode', 'OperatorNode', 'ParenthesisNode', 'SymbolNode'];\nexport var createSimplifyCore = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    equal,\n    isZero,\n    add,\n    subtract,\n    multiply,\n    divide,\n    pow,\n    AccessorNode,\n    ArrayNode,\n    ConstantNode,\n    FunctionNode,\n    IndexNode,\n    ObjectNode,\n    OperatorNode,\n    ParenthesisNode,\n    SymbolNode\n  } = _ref;\n  var node0 = new ConstantNode(0);\n  var node1 = new ConstantNode(1);\n  var {\n    hasProperty,\n    isCommutative\n  } = createUtil({\n    FunctionNode,\n    OperatorNode,\n    SymbolNode\n  });\n  /**\n   * simplifyCore() performs single pass simplification suitable for\n   * applications requiring ultimate performance. In contrast, simplify()\n   * extends simplifyCore() with additional passes to provide deeper\n   * simplification.\n   *\n   * Syntax:\n   *\n   *     simplifyCore(expr)\n   *\n   * Examples:\n   *\n   *     const f = math.parse('2 * 1 * x ^ (2 - 1)')\n   *     math.simpifyCore(f)                          // Node {2 * x}\n   *     math.simplify('2 * 1 * x ^ (2 - 1)', [math.simplifyCore]) // Node {2 * x}\n   *\n   * See also:\n   *\n   *     simplify, resolve, derivative\n   *\n   * @param {Node} node\n   *     The expression to be simplified\n   * @param {Object} options\n   *     Simplification options, as per simplify()\n   * @return {Node} Returns expression with basic simplifications applied\n   */\n\n  function simplifyCore(node, options) {\n    var context = options ? options.context : undefined;\n\n    if (hasProperty(node, 'trivial', context)) {\n      // This node does nothing if it has only one argument, so if so,\n      // return that argument simplified\n      if (isFunctionNode(node) && node.args.length === 1) {\n        return simplifyCore(node.args[0], options);\n      } // For other node types, we try the generic methods\n\n\n      var simpChild = false;\n      var childCount = 0;\n      node.forEach(c => {\n        ++childCount;\n\n        if (childCount === 1) {\n          simpChild = simplifyCore(c, options);\n        }\n      });\n\n      if (childCount === 1) {\n        return simpChild;\n      }\n    }\n\n    if (isOperatorNode(node) && node.isUnary()) {\n      var a0 = simplifyCore(node.args[0], options);\n\n      if (node.op === '-') {\n        // unary minus\n        if (isOperatorNode(a0)) {\n          if (a0.isUnary() && a0.op === '-') {\n            return a0.args[0];\n          } else if (a0.isBinary() && a0.fn === 'subtract') {\n            return new OperatorNode('-', 'subtract', [a0.args[1], a0.args[0]]);\n          }\n        }\n\n        return new OperatorNode(node.op, node.fn, [a0]);\n      }\n    } else if (isOperatorNode(node) && node.isBinary()) {\n      var _a = simplifyCore(node.args[0], options);\n\n      var a1 = simplifyCore(node.args[1], options);\n\n      if (node.op === '+') {\n        if (isConstantNode(_a)) {\n          if (isZero(_a.value)) {\n            return a1;\n          } else if (isConstantNode(a1)) {\n            return new ConstantNode(add(_a.value, a1.value));\n          }\n        }\n\n        if (isConstantNode(a1) && isZero(a1.value)) {\n          return _a;\n        }\n\n        if (isOperatorNode(a1) && a1.isUnary() && a1.op === '-') {\n          return new OperatorNode('-', 'subtract', [_a, a1.args[0]]);\n        }\n\n        return new OperatorNode(node.op, node.fn, a1 ? [_a, a1] : [_a]);\n      } else if (node.op === '-') {\n        if (isConstantNode(_a) && a1) {\n          if (isConstantNode(a1)) {\n            return new ConstantNode(subtract(_a.value, a1.value));\n          } else if (isZero(_a.value)) {\n            return new OperatorNode('-', 'unaryMinus', [a1]);\n          }\n        } // if (node.fn === \"subtract\" && node.args.length === 2) {\n\n\n        if (node.fn === 'subtract') {\n          if (isConstantNode(a1) && isZero(a1.value)) {\n            return _a;\n          }\n\n          if (isOperatorNode(a1) && a1.isUnary() && a1.op === '-') {\n            return simplifyCore(new OperatorNode('+', 'add', [_a, a1.args[0]]), options);\n          }\n\n          return new OperatorNode(node.op, node.fn, [_a, a1]);\n        }\n      } else if (node.op === '*') {\n        if (isConstantNode(_a)) {\n          if (isZero(_a.value)) {\n            return node0;\n          } else if (equal(_a.value, 1)) {\n            return a1;\n          } else if (isConstantNode(a1)) {\n            return new ConstantNode(multiply(_a.value, a1.value));\n          }\n        }\n\n        if (isConstantNode(a1)) {\n          if (isZero(a1.value)) {\n            return node0;\n          } else if (equal(a1.value, 1)) {\n            return _a;\n          } else if (isOperatorNode(_a) && _a.isBinary() && _a.op === node.op && isCommutative(node, context)) {\n            var a00 = _a.args[0];\n\n            if (isConstantNode(a00)) {\n              var a00a1 = new ConstantNode(multiply(a00.value, a1.value));\n              return new OperatorNode(node.op, node.fn, [a00a1, _a.args[1]], node.implicit); // constants on left\n            }\n          }\n\n          if (isCommutative(node, context)) {\n            return new OperatorNode(node.op, node.fn, [a1, _a], node.implicit); // constants on left\n          } else {\n            return new OperatorNode(node.op, node.fn, [_a, a1], node.implicit);\n          }\n        }\n\n        return new OperatorNode(node.op, node.fn, [_a, a1], node.implicit);\n      } else if (node.op === '/') {\n        if (isConstantNode(_a)) {\n          if (isZero(_a.value)) {\n            return node0;\n          } else if (isConstantNode(a1) && (equal(a1.value, 1) || equal(a1.value, 2) || equal(a1.value, 4))) {\n            return new ConstantNode(divide(_a.value, a1.value));\n          }\n        }\n\n        return new OperatorNode(node.op, node.fn, [_a, a1]);\n      } else if (node.op === '^') {\n        if (isConstantNode(a1)) {\n          if (isZero(a1.value)) {\n            return node1;\n          } else if (equal(a1.value, 1)) {\n            return _a;\n          } else {\n            if (isConstantNode(_a)) {\n              // fold constant\n              return new ConstantNode(pow(_a.value, a1.value));\n            } else if (isOperatorNode(_a) && _a.isBinary() && _a.op === '^') {\n              var a01 = _a.args[1];\n\n              if (isConstantNode(a01)) {\n                return new OperatorNode(node.op, node.fn, [_a.args[0], new ConstantNode(multiply(a01.value, a1.value))]);\n              }\n            }\n          }\n        }\n      }\n\n      return new OperatorNode(node.op, node.fn, [_a, a1]);\n    } else if (isFunctionNode(node)) {\n      return new FunctionNode(simplifyCore(node.fn), node.args.map(n => simplifyCore(n, options)));\n    } else if (isArrayNode(node)) {\n      return new ArrayNode(node.items.map(n => simplifyCore(n, options)));\n    } else if (isAccessorNode(node)) {\n      return new AccessorNode(simplifyCore(node.object, options), simplifyCore(node.index, options));\n    } else if (isIndexNode(node)) {\n      return new IndexNode(node.dimensions.map(n => simplifyCore(n, options)));\n    } else if (isObjectNode(node)) {\n      var newProps = {};\n\n      for (var prop in node.properties) {\n        newProps[prop] = simplifyCore(node.properties[prop], options);\n      }\n\n      return new ObjectNode(newProps);\n    } else {// cannot simplify\n    }\n\n    return node;\n  }\n\n  return simplifyCore;\n});","map":{"version":3,"sources":["F:/Task-2/Frontend/node_modules/mathjs/lib/esm/function/algebra/simplifyCore.js"],"names":["isAccessorNode","isArrayNode","isConstantNode","isFunctionNode","isIndexNode","isObjectNode","isOperatorNode","createUtil","factory","name","dependencies","createSimplifyCore","_ref","equal","isZero","add","subtract","multiply","divide","pow","AccessorNode","ArrayNode","ConstantNode","FunctionNode","IndexNode","ObjectNode","OperatorNode","ParenthesisNode","SymbolNode","node0","node1","hasProperty","isCommutative","simplifyCore","node","options","context","undefined","args","length","simpChild","childCount","forEach","c","isUnary","a0","op","isBinary","fn","_a","a1","value","a00","a00a1","implicit","a01","map","n","items","object","index","dimensions","newProps","prop","properties"],"mappings":"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","sourcesContent":["import { isAccessorNode, isArrayNode, isConstantNode, isFunctionNode, isIndexNode, isObjectNode, isOperatorNode } from '../../utils/is.js';\nimport { createUtil } from './simplify/util.js';\nimport { factory } from '../../utils/factory.js';\nvar name = 'simplifyCore';\nvar dependencies = ['equal', 'isZero', 'add', 'subtract', 'multiply', 'divide', 'pow', 'AccessorNode', 'ArrayNode', 'ConstantNode', 'FunctionNode', 'IndexNode', 'ObjectNode', 'OperatorNode', 'ParenthesisNode', 'SymbolNode'];\nexport var createSimplifyCore = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    equal,\n    isZero,\n    add,\n    subtract,\n    multiply,\n    divide,\n    pow,\n    AccessorNode,\n    ArrayNode,\n    ConstantNode,\n    FunctionNode,\n    IndexNode,\n    ObjectNode,\n    OperatorNode,\n    ParenthesisNode,\n    SymbolNode\n  } = _ref;\n  var node0 = new ConstantNode(0);\n  var node1 = new ConstantNode(1);\n  var {\n    hasProperty,\n    isCommutative\n  } = createUtil({\n    FunctionNode,\n    OperatorNode,\n    SymbolNode\n  });\n  /**\n   * simplifyCore() performs single pass simplification suitable for\n   * applications requiring ultimate performance. In contrast, simplify()\n   * extends simplifyCore() with additional passes to provide deeper\n   * simplification.\n   *\n   * Syntax:\n   *\n   *     simplifyCore(expr)\n   *\n   * Examples:\n   *\n   *     const f = math.parse('2 * 1 * x ^ (2 - 1)')\n   *     math.simpifyCore(f)                          // Node {2 * x}\n   *     math.simplify('2 * 1 * x ^ (2 - 1)', [math.simplifyCore]) // Node {2 * x}\n   *\n   * See also:\n   *\n   *     simplify, resolve, derivative\n   *\n   * @param {Node} node\n   *     The expression to be simplified\n   * @param {Object} options\n   *     Simplification options, as per simplify()\n   * @return {Node} Returns expression with basic simplifications applied\n   */\n\n  function simplifyCore(node, options) {\n    var context = options ? options.context : undefined;\n\n    if (hasProperty(node, 'trivial', context)) {\n      // This node does nothing if it has only one argument, so if so,\n      // return that argument simplified\n      if (isFunctionNode(node) && node.args.length === 1) {\n        return simplifyCore(node.args[0], options);\n      } // For other node types, we try the generic methods\n\n\n      var simpChild = false;\n      var childCount = 0;\n      node.forEach(c => {\n        ++childCount;\n\n        if (childCount === 1) {\n          simpChild = simplifyCore(c, options);\n        }\n      });\n\n      if (childCount === 1) {\n        return simpChild;\n      }\n    }\n\n    if (isOperatorNode(node) && node.isUnary()) {\n      var a0 = simplifyCore(node.args[0], options);\n\n      if (node.op === '-') {\n        // unary minus\n        if (isOperatorNode(a0)) {\n          if (a0.isUnary() && a0.op === '-') {\n            return a0.args[0];\n          } else if (a0.isBinary() && a0.fn === 'subtract') {\n            return new OperatorNode('-', 'subtract', [a0.args[1], a0.args[0]]);\n          }\n        }\n\n        return new OperatorNode(node.op, node.fn, [a0]);\n      }\n    } else if (isOperatorNode(node) && node.isBinary()) {\n      var _a = simplifyCore(node.args[0], options);\n\n      var a1 = simplifyCore(node.args[1], options);\n\n      if (node.op === '+') {\n        if (isConstantNode(_a)) {\n          if (isZero(_a.value)) {\n            return a1;\n          } else if (isConstantNode(a1)) {\n            return new ConstantNode(add(_a.value, a1.value));\n          }\n        }\n\n        if (isConstantNode(a1) && isZero(a1.value)) {\n          return _a;\n        }\n\n        if (isOperatorNode(a1) && a1.isUnary() && a1.op === '-') {\n          return new OperatorNode('-', 'subtract', [_a, a1.args[0]]);\n        }\n\n        return new OperatorNode(node.op, node.fn, a1 ? [_a, a1] : [_a]);\n      } else if (node.op === '-') {\n        if (isConstantNode(_a) && a1) {\n          if (isConstantNode(a1)) {\n            return new ConstantNode(subtract(_a.value, a1.value));\n          } else if (isZero(_a.value)) {\n            return new OperatorNode('-', 'unaryMinus', [a1]);\n          }\n        } // if (node.fn === \"subtract\" && node.args.length === 2) {\n\n\n        if (node.fn === 'subtract') {\n          if (isConstantNode(a1) && isZero(a1.value)) {\n            return _a;\n          }\n\n          if (isOperatorNode(a1) && a1.isUnary() && a1.op === '-') {\n            return simplifyCore(new OperatorNode('+', 'add', [_a, a1.args[0]]), options);\n          }\n\n          return new OperatorNode(node.op, node.fn, [_a, a1]);\n        }\n      } else if (node.op === '*') {\n        if (isConstantNode(_a)) {\n          if (isZero(_a.value)) {\n            return node0;\n          } else if (equal(_a.value, 1)) {\n            return a1;\n          } else if (isConstantNode(a1)) {\n            return new ConstantNode(multiply(_a.value, a1.value));\n          }\n        }\n\n        if (isConstantNode(a1)) {\n          if (isZero(a1.value)) {\n            return node0;\n          } else if (equal(a1.value, 1)) {\n            return _a;\n          } else if (isOperatorNode(_a) && _a.isBinary() && _a.op === node.op && isCommutative(node, context)) {\n            var a00 = _a.args[0];\n\n            if (isConstantNode(a00)) {\n              var a00a1 = new ConstantNode(multiply(a00.value, a1.value));\n              return new OperatorNode(node.op, node.fn, [a00a1, _a.args[1]], node.implicit); // constants on left\n            }\n          }\n\n          if (isCommutative(node, context)) {\n            return new OperatorNode(node.op, node.fn, [a1, _a], node.implicit); // constants on left\n          } else {\n            return new OperatorNode(node.op, node.fn, [_a, a1], node.implicit);\n          }\n        }\n\n        return new OperatorNode(node.op, node.fn, [_a, a1], node.implicit);\n      } else if (node.op === '/') {\n        if (isConstantNode(_a)) {\n          if (isZero(_a.value)) {\n            return node0;\n          } else if (isConstantNode(a1) && (equal(a1.value, 1) || equal(a1.value, 2) || equal(a1.value, 4))) {\n            return new ConstantNode(divide(_a.value, a1.value));\n          }\n        }\n\n        return new OperatorNode(node.op, node.fn, [_a, a1]);\n      } else if (node.op === '^') {\n        if (isConstantNode(a1)) {\n          if (isZero(a1.value)) {\n            return node1;\n          } else if (equal(a1.value, 1)) {\n            return _a;\n          } else {\n            if (isConstantNode(_a)) {\n              // fold constant\n              return new ConstantNode(pow(_a.value, a1.value));\n            } else if (isOperatorNode(_a) && _a.isBinary() && _a.op === '^') {\n              var a01 = _a.args[1];\n\n              if (isConstantNode(a01)) {\n                return new OperatorNode(node.op, node.fn, [_a.args[0], new ConstantNode(multiply(a01.value, a1.value))]);\n              }\n            }\n          }\n        }\n      }\n\n      return new OperatorNode(node.op, node.fn, [_a, a1]);\n    } else if (isFunctionNode(node)) {\n      return new FunctionNode(simplifyCore(node.fn), node.args.map(n => simplifyCore(n, options)));\n    } else if (isArrayNode(node)) {\n      return new ArrayNode(node.items.map(n => simplifyCore(n, options)));\n    } else if (isAccessorNode(node)) {\n      return new AccessorNode(simplifyCore(node.object, options), simplifyCore(node.index, options));\n    } else if (isIndexNode(node)) {\n      return new IndexNode(node.dimensions.map(n => simplifyCore(n, options)));\n    } else if (isObjectNode(node)) {\n      var newProps = {};\n\n      for (var prop in node.properties) {\n        newProps[prop] = simplifyCore(node.properties[prop], options);\n      }\n\n      return new ObjectNode(newProps);\n    } else {// cannot simplify\n    }\n\n    return node;\n  }\n\n  return simplifyCore;\n});"]},"metadata":{},"sourceType":"module"}